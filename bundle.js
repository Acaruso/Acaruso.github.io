/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"App\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var _event_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event_table */ \"./src/event_table.js\");\n/* harmony import */ var _gfx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gfx */ \"./src/gfx.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer */ \"./src/renderer.js\");\n/* harmony import */ var _scripter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripter */ \"./src/scripter.js\");\n/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./state */ \"./src/state.js\");\n/* harmony import */ var _tree_formatter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tree_formatter */ \"./src/tree_formatter.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui */ \"./src/ui.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass App {\r\n    constructor() {\r\n        this.gfx = new _gfx__WEBPACK_IMPORTED_MODULE_1__.Gfx();\r\n        this.state = new _state__WEBPACK_IMPORTED_MODULE_5__.State();\r\n        this.model = new _model__WEBPACK_IMPORTED_MODULE_2__.Model();\r\n        this.treeFormatter = new _tree_formatter__WEBPACK_IMPORTED_MODULE_6__.TreeFormatter(this.model);\r\n        this.scripter = new _scripter__WEBPACK_IMPORTED_MODULE_4__.Scripter(this.model, this.treeFormatter);\r\n        this.eventTable = new _event_table__WEBPACK_IMPORTED_MODULE_0__.EventTable(this.state, this.model);\r\n        this.ui = new _ui__WEBPACK_IMPORTED_MODULE_7__.Ui(\r\n            this.state,\r\n            this.model,\r\n            this.eventTable,\r\n            this.scripter,\r\n            this.treeFormatter,\r\n        );\r\n        this.renderer = new _renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer(this.gfx, this.state, this.model);\r\n        this.interval = {};\r\n    }\r\n\r\n    startMainLoop() {\r\n        // this.scripter.run();\r\n        this.interval = setInterval(() => this.loop(), 10);\r\n    }\r\n\r\n    loop() {\r\n        this.gfx.clearScreen();\r\n        this.ui.run();\r\n        this.renderer.render();\r\n        this.gfx.draw();\r\n        this.state.nextState();\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/app.js?");

/***/ }),

/***/ "./src/box.js":
/*!********************!*\
  !*** ./src/box.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Box\": () => (/* binding */ Box)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\r\n\r\nclass Box {\r\n    constructor(text, coord, id=0) {\r\n        this.coord = { ...coord };\r\n        this.id = id;\r\n        this.text = text.split('\\n');\r\n        this.rect = {};\r\n        this.parentId = null;\r\n\r\n        this.updateRect();\r\n    }\r\n\r\n    appendString(s) {\r\n        const arr = s.split('\\n');\r\n\r\n        if (s === \"\\n\") {\r\n            this.text.push(\"\");\r\n        } else if (arr.length > 1) {\r\n            for (const elt of arr) {\r\n                if (elt !== \"\") {\r\n                    this.text.push(elt);\r\n                }\r\n            }\r\n        } else {\r\n            this.text[this.text.length - 1] += s;\r\n        }\r\n\r\n        this.updateRect();\r\n    }\r\n\r\n    deleteChar() {\r\n        if (this.text[this.text.length - 1].length > 0) {\r\n            this.text[this.text.length - 1] = this.text[this.text.length - 1].slice(0, -1);\r\n        } else if (this.text.length > 1) {      // don't allow to delete last string from arr\r\n            this.text = this.text.slice(0, -1);\r\n        }\r\n\r\n        this.updateRect();\r\n    }\r\n\r\n    setCoord(newCoord) {\r\n        this.coord = {\r\n            x: Math.floor(newCoord.x),\r\n            y: Math.floor(newCoord.y)\r\n        };\r\n        this.updateRect();\r\n    }\r\n\r\n    setX(x) {\r\n        this.coord.x = Math.floor(x);\r\n        this.updateRect();\r\n    }\r\n\r\n    setY(y) {\r\n        this.coord.y = Math.floor(y);\r\n        this.updateRect();\r\n    }\r\n\r\n    updateRect() {\r\n        this.rect = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getTextRect)(this.text, this.coord);\r\n\r\n        // const length = this.text.length > 0 ? this.text.length : 1;\r\n\r\n        // this.rect = {\r\n        //     x: this.coord.x,\r\n        //     y: this.coord.y,\r\n        //     w: Math.floor(length * textConstants.charWidth) + (textConstants.xPadding * 2),\r\n        //     h: textConstants.charHeight + textConstants.yPadding\r\n        // };\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/box.js?");

/***/ }),

/***/ "./src/boxes.js":
/*!**********************!*\
  !*** ./src/boxes.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Boxes\": () => (/* binding */ Boxes)\n/* harmony export */ });\n/* harmony import */ var _box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./box */ \"./src/box.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\r\n\r\n\r\nclass Boxes {\r\n    constructor() {\r\n        this.boxes = [];\r\n        this.nextId = 0;\r\n\r\n        // key: id of source\r\n        // value: array of ids of destinations\r\n        // ex: {\r\n        //     1: [2, 3, 4],\r\n        //     2: [8, 9]\r\n        // }\r\n        this.connections = new Map();\r\n    }\r\n\r\n    addBox(text, coord) {\r\n        const box = new _box__WEBPACK_IMPORTED_MODULE_0__.Box(text, coord, this.nextId);\r\n        this.nextId++;\r\n        this.boxes.push(box);\r\n        this.connections.set(box.id, []);\r\n        return box.id;\r\n    }\r\n\r\n    cloneBox(box, coord) {\r\n        let newBox = new _box__WEBPACK_IMPORTED_MODULE_0__.Box(\"\", coord, this.nextId);\r\n        this.nextId++;\r\n        newBox.text = [...box.text];\r\n        newBox.updateRect();\r\n        this.boxes.push(newBox);\r\n        this.connections.set(newBox.id, []);\r\n        return newBox.id;\r\n    }\r\n\r\n    getLength() {\r\n        return this.boxes.length;\r\n    }\r\n\r\n    loadBoxes(boxesStr) {\r\n        const boxData = JSON.parse(boxesStr);\r\n        let maxId = -1;\r\n\r\n        for (const x of boxData) {\r\n            const joinedStr = x.text.join(\"\\n\");\r\n            const box = new _box__WEBPACK_IMPORTED_MODULE_0__.Box(joinedStr, x.coord, x.id);\r\n            this.boxes.push(box);\r\n            maxId = Math.max(maxId, x.id);\r\n        }\r\n\r\n        this.nextId = maxId + 1;\r\n    }\r\n\r\n    loadConnections(connStr) {\r\n        this.connections = new Map(JSON.parse(connStr));\r\n    }\r\n\r\n    getBoxes() {\r\n        return this.boxes;\r\n    }\r\n\r\n    getBox(id) {\r\n        return this.boxes.find((box) => box.id === id);\r\n    }\r\n\r\n    deleteBox(id) {\r\n        this.deleteConnections(id);\r\n        this.boxes = this.boxes.filter((box) => box.id !== id);\r\n    }\r\n\r\n    deleteAll() {\r\n        (0,_util__WEBPACK_IMPORTED_MODULE_1__.clearArray)(this.boxes);\r\n        this.connections.clear();\r\n    }\r\n\r\n    addConnection(source, dest) {\r\n        let destArr = this.connections.get(source);\r\n\r\n        if (!destArr.includes(dest)) {\r\n            destArr.push(dest);\r\n        }\r\n    }\r\n\r\n    getAllConnections() {\r\n        let out = [];\r\n\r\n        for (const [source, destArr] of this.connections) {\r\n            for (const dest of destArr) {\r\n                out.push([\r\n                    this.getBox(source),\r\n                    this.getBox(dest)\r\n                ]);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    getConnections(id) {\r\n        return this.connections.has(id)\r\n            ? this.connections.get(id)\r\n            : [];\r\n    }\r\n\r\n    deleteConnections(id) {\r\n        this.connections.delete(id);\r\n        for (let [source, destArr] of this.connections) {\r\n            this.connections.set(source, destArr.filter(x => x !== id));\r\n        }\r\n    }\r\n\r\n    forEach(fn) {\r\n        this.boxes.forEach(fn);\r\n    }\r\n\r\n    // tree methods ///////////////////\r\n\r\n    hasParent(id) {\r\n        const box = this.getBox(id);\r\n        return (box.parentId !== null);\r\n    }\r\n\r\n    isLeaf(id) {\r\n        const childIds = this.getConnections(id);\r\n        return (childIds.length === 0);\r\n    }\r\n\r\n    isLeftMost(id) {\r\n        const box = this.getBox(id);\r\n        if (box.parentId === null) {\r\n            return true;\r\n        } else {\r\n            const parentChildIds = this.getConnections(box.parentId);\r\n            return ((0,_util__WEBPACK_IMPORTED_MODULE_1__.firstElt)(parentChildIds) === id);\r\n        }\r\n    }\r\n\r\n    isRightMost(id) {\r\n        const box = this.getBox(id);\r\n        if (box.parentId === null) {\r\n            return true;\r\n        } else {\r\n            const parentChildIds = this.getConnections(box.parentId);\r\n            return ((0,_util__WEBPACK_IMPORTED_MODULE_1__.lastElt)(parentChildIds) === id);\r\n        }\r\n    }\r\n\r\n    getPrevSibling(id) {\r\n        const box = this.getBox(id);\r\n        if (box.parentId === null || this.isLeftMost(id)) {\r\n            return null;\r\n        } else {\r\n            const parentChildIds = this.getConnections(box.parentId);\r\n            const thisIdx = parentChildIds.indexOf(id);\r\n            return parentChildIds[thisIdx - 1];\r\n        }\r\n    }\r\n\r\n    getNextSibling(id) {\r\n        const box = this.getBox(id);\r\n        if (box.parentId === null || this.isRightMost(id)) {\r\n            return null;\r\n        } else {\r\n            const parentChildIds = this.getConnections(box.parentId);\r\n            const thisIdx = parentChildIds.indexOf(id);\r\n            return parentChildIds[thisIdx + 1];\r\n        }\r\n    }\r\n\r\n    getLeftMostSibling(id) {\r\n        const box = this.getBox(id);\r\n        if (box.parentId === null) {\r\n            return null;\r\n        } else if (this.isLeftMost(id)) {\r\n            return id;\r\n        } else {\r\n            const parentChildIds = this.getConnections(box.parentId);\r\n            return (0,_util__WEBPACK_IMPORTED_MODULE_1__.firstElt)(parentChildIds);\r\n        }\r\n    }\r\n\r\n    getLeftMostChild(id) {\r\n        const childIds = this.getConnections(id);\r\n        if (childIds.length === 0) {\r\n            return null;\r\n        } else {\r\n            return (0,_util__WEBPACK_IMPORTED_MODULE_1__.firstElt)(childIds);\r\n        }\r\n    }\r\n\r\n    getRightMostChild(id) {\r\n        const childIds = this.getConnections(id);\r\n        if (childIds.length === 0) {\r\n            return null;\r\n        } else {\r\n            return (0,_util__WEBPACK_IMPORTED_MODULE_1__.lastElt)(childIds);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/boxes.js?");

/***/ }),

/***/ "./src/event_table.js":
/*!****************************!*\
  !*** ./src/event_table.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventTable\": () => (/* binding */ EventTable)\n/* harmony export */ });\nclass EventTable {\r\n    constructor(state, model) {\r\n        this.state = state;\r\n        this.model = model;\r\n        this.table = [];\r\n    }\r\n\r\n    addEvent(name, shouldRun, run) {\r\n        this.table.push([name, shouldRun, run]);\r\n    }\r\n\r\n    formatEvent(e) {\r\n        e.key_ = e.key ? e.key.toLowerCase() : \"\";\r\n\r\n        if (e.key_ === \"enter\") {\r\n            e.key_ = \"\\n\";\r\n        }\r\n\r\n        e.mousedown = e.type === \"mousedown\";\r\n        e.mouseup = e.type === \"mouseup\";\r\n        e.keydown = e.type === \"keydown\";\r\n        e.dblclick = e.type === \"dblclick\";\r\n        e.insideBox = false;\r\n        e.mouseBox = null;\r\n        e.keyboard = this.state.cur.keyboard;\r\n        e.mouse = this.state.cur.mouse;\r\n    }\r\n\r\n    enrichEvent(e) {\r\n        this.formatEvent(e);\r\n        const boxes = this.model.boxes;\r\n\r\n        boxes.forEach((box) => {\r\n            if (this.state.isMouseInside(box.rect)) {\r\n                e.insideBox = true;\r\n                e.mouseBox = box;\r\n            }\r\n        });\r\n\r\n        // if (e.mousedown || e.mouseup) {\r\n        //     boxes.forEach((box) => {\r\n        //         if (this.state.isMouseInside(box.rect)) {\r\n        //             e.insideBox = true;\r\n        //             e.mouseBox = box;\r\n        //         }\r\n        //     });\r\n        // }\r\n\r\n        return e;\r\n    }\r\n\r\n    onEvent(e) {\r\n        this.enrichEvent(e);\r\n        for (const [name, shouldRun, run] of this.table) {\r\n            if (shouldRun(e)) {\r\n                run(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/event_table.js?");

/***/ }),

/***/ "./src/gfx.js":
/*!********************!*\
  !*** ./src/gfx.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gfx\": () => (/* binding */ Gfx)\n/* harmony export */ });\n/* harmony import */ var _text_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text_constants */ \"./src/text_constants.js\");\n\r\n\r\nclass Gfx {\r\n    constructor() {\r\n        this.canvas = document.getElementById(\"myCanvas\")\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.queue = [];\r\n    }\r\n\r\n    drawRect(rect, z=0) {\r\n        const command = (ctx) => {\r\n            const color = rect.color ? rect.color : \"#000000\";\r\n\r\n            // 0.0 == transparent, 1.0 == solid\r\n            const alpha = rect.alpha ? rect.alpha : 1.0;\r\n\r\n            this.ctx.globalAlpha = alpha;\r\n            ctx.fillStyle = color;\r\n            ctx.beginPath();\r\n            ctx.rect(rect.x, rect.y, rect.w, rect.h);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n            this.ctx.globalAlpha = 1.0;\r\n        };\r\n\r\n        this.queue.push({\r\n            command,\r\n            z: z\r\n        });\r\n    }\r\n\r\n    strokeRect(rect, z=0, color=\"#000000\") {\r\n        const upperLeft = { x: rect.x, y: rect.y };\r\n        const upperRight = { x: rect.x + rect.w, y: rect.y };\r\n        const lowerRight = { x: rect.x + rect.w, y: rect.y + rect.h };\r\n        const lowerLeft = { x: rect.x, y: rect.y + rect.h };\r\n\r\n        this.drawLine(upperLeft, upperRight, z, color);\r\n        this.drawLine(upperRight, lowerRight, z, color);\r\n        this.drawLine(lowerRight, lowerLeft, z, color);\r\n        this.drawLine(lowerLeft, upperLeft, z, color);\r\n    }\r\n\r\n    // note that y-coord is *bottom* left side of text\r\n    drawText(text, size, coord, z=0) {\r\n        const command = (ctx) => {\r\n            ctx.font = `${size}px ${_text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.textStyle}`;\r\n            ctx.fillStyle = \"#000000\";\r\n            ctx.fillText(text, coord.x, coord.y);\r\n        };\r\n\r\n        this.queue.push({\r\n            command,\r\n            z: z\r\n        });\r\n    }\r\n\r\n    drawLine(beginCoord, endCoord, z=0, color=\"#000000\") {\r\n        const command = (ctx) => {\r\n            ctx.strokeStyle = color;\r\n            ctx.beginPath();\r\n            ctx.moveTo(beginCoord.x, beginCoord.y);\r\n            ctx.lineTo(endCoord.x, endCoord.y);\r\n            ctx.stroke();\r\n        };\r\n\r\n        this.queue.push({\r\n            command,\r\n            z: z\r\n        });\r\n    }\r\n\r\n    draw() {\r\n        this.queue.sort((first, second) => {\r\n            return second.z - first.z;\r\n        });\r\n\r\n        while (this.queue.length > 0) {\r\n            const elt = this.queue[this.queue.length - 1];\r\n            elt.command(this.ctx);\r\n            this.queue.pop();\r\n        }\r\n    }\r\n\r\n    clearScreen() {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/gfx.js?");

/***/ }),

/***/ "./src/help_dialog.js":
/*!****************************!*\
  !*** ./src/help_dialog.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HelpDialog\": () => (/* binding */ HelpDialog)\n/* harmony export */ });\n/* harmony import */ var _text_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text_constants */ \"./src/text_constants.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\r\n\r\n\r\nclass HelpDialog {\r\n    constructor() {\r\n        this.visible = true;\r\n\r\n        this.text = [\r\n            \"Welcome to Boxes and Lines\",\r\n            \"\",\r\n            \"Controls:\",\r\n            \"Create a box: double click\",\r\n            \"Create a connection: Ctrl-click within a box,\",\r\n            \"    then drag to another box\",\r\n            \"Duplicate a box: Alt-click within a box\",\r\n            \"Delete selected boxes: Delete\",\r\n            \"Select all boxes: Ctrl-A\",\r\n            \"Tree format: select root node, then do Ctrl-Q\",\r\n            \"Horizontally align selected boxes: Ctrl-H\",\r\n            \"Vertically align selected boxes: Ctrl-V\",\r\n            \"Save file: Ctrl-S\",\r\n            \"Load file: Ctrl-L\",\r\n            \"Load script: Ctrl-Shift-L\",\r\n        ];\r\n\r\n        this.coord = { x: 200, y: 200 };\r\n\r\n        this.rect = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getTextRect)(this.text, this.coord);\r\n\r\n        this.rect.color = \"#A3BFFF\";\r\n\r\n        const cbW = _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.charHeight;\r\n\r\n        this.closeButtonRect = {\r\n            x: (this.rect.x + this.rect.w) - (cbW + _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.yPadding),\r\n            y: this.rect.y + _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.yPadding,\r\n            w: cbW,\r\n            h: _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.charHeight,\r\n        };\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/help_dialog.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app */ \"./src/app.js\");\n\r\n\r\ndocument.body.onload = () => {\r\n    const app = new _app__WEBPACK_IMPORTED_MODULE_0__.App();\r\n    app.startMainLoop();\r\n};\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/index.js?");

/***/ }),

/***/ "./src/model.js":
/*!**********************!*\
  !*** ./src/model.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Model\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _boxes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boxes */ \"./src/boxes.js\");\n/* harmony import */ var _help_dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./help_dialog */ \"./src/help_dialog.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\r\n\r\n\r\n\r\nclass Model {\r\n    constructor() {\r\n        this.boxes = new _boxes__WEBPACK_IMPORTED_MODULE_0__.Boxes();\r\n        this.helpDialog = new _help_dialog__WEBPACK_IMPORTED_MODULE_1__.HelpDialog();\r\n\r\n        this.selectedBoxIds = [];\r\n\r\n        this.draggingBoxes = false;\r\n        this.draggingSelectedRegion = false;\r\n\r\n        this.lineBegin = { x: 0, y: 0 };\r\n        this.drawingLine = false;\r\n        this.outBox = {};\r\n\r\n        this.selectedRegion = { x: 0, y: 0, w: 0, h: 0, alpha: 0.3 };\r\n    }\r\n\r\n    init() {\r\n        this.boxes.deleteAll();\r\n        (0,_util__WEBPACK_IMPORTED_MODULE_2__.clearArray)(this.selectedBoxIds);\r\n        this.draggingBoxes = false;\r\n        this.draggingSelectedRegion = false;\r\n        this.lineBegin = { x: 0, y: 0 };\r\n        this.drawingLine = false;\r\n        this.outBox = {};\r\n        this.selectedRegion = { x: 0, y: 0, w: 0, h: 0, alpha: 0.3 };\r\n    }\r\n\r\n    anyBoxesSelected() {\r\n        return this.selectedBoxIds.length > 0;\r\n    }\r\n\r\n    isBoxSelected(id) {\r\n        return this.selectedBoxIds.includes(id);\r\n    }\r\n\r\n    addSelectedBoxId(id) {\r\n        if (!this.selectedBoxIds.includes(id)) {\r\n            this.selectedBoxIds.push(id);\r\n        }\r\n    }\r\n\r\n    clearSelectedBoxIds() {\r\n        while (this.selectedBoxIds.length > 0) {\r\n            this.selectedBoxIds.pop();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/model.js?");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Renderer\": () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _text_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text_constants */ \"./src/text_constants.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\r\n\r\n\r\nclass Renderer {\r\n    constructor(gfx, state, model) {\r\n        this.gfx = gfx;\r\n        this.state = state;\r\n        this.model = model;\r\n    }\r\n\r\n    render() {\r\n        this.drawBoxes();\r\n        this.drawSelectedBoxes();\r\n        this.drawLine();\r\n        this.drawConnections();\r\n        this.drawSelectedRegion();\r\n        this.drawHelpDialog();\r\n    }\r\n\r\n    drawBoxes() {\r\n        this.model.boxes.forEach(box => this.drawBox(box));\r\n    }\r\n\r\n    drawBox(box) {\r\n        this.drawBoxRect(box);\r\n        this.drawBoxText(box);\r\n    }\r\n\r\n    drawBoxRect(box) {\r\n        const bgRect = {\r\n            ...box.rect,\r\n            color: \"#FFFFFF\"\r\n        };\r\n\r\n        this.gfx.drawRect(bgRect, 0);\r\n        this.gfx.strokeRect(box.rect, 1);\r\n    }\r\n\r\n    drawBoxText(box) {\r\n        this.drawMultiLineText(box.text, box.coord, 2);\r\n    }\r\n\r\n    drawSelectedBoxes() {\r\n        const boxes = this.model.boxes;\r\n\r\n        for (const selectedBoxId of this.model.selectedBoxIds) {\r\n            const selectedBox = boxes.getBox(selectedBoxId);\r\n            const rect = { ...selectedBox.rect };\r\n            rect.x -= 2;\r\n            rect.y -= 2;\r\n            rect.w += 4;\r\n            rect.h += 4;\r\n            this.gfx.strokeRect(rect);\r\n        }\r\n    }\r\n\r\n    drawLine() {\r\n        if (\r\n            this.state.cur.mouse.clicked\r\n            && this.state.cur.keyboard.control\r\n            && this.model.drawingLine\r\n        ) {\r\n            const curMouse = this.state.cur.mouse;\r\n            this.gfx.drawLine(this.model.lineBegin, { ...curMouse.coord }, -1);\r\n        }\r\n    }\r\n\r\n    drawConnections() {\r\n        this.model.boxes.getAllConnections()\r\n            .map(([box1, box2]) => [(0,_util__WEBPACK_IMPORTED_MODULE_1__.getMidpoint)(box1.rect), (0,_util__WEBPACK_IMPORTED_MODULE_1__.getMidpoint)(box2.rect)])\r\n            .forEach(([begin, end]) => this.gfx.drawLine(begin, end, -1));\r\n    }\r\n\r\n    drawSelectedRegion() {\r\n        if (this.model.draggingSelectedRegion) {\r\n            this.gfx.drawRect(this.model.selectedRegion, 10);\r\n        }\r\n    }\r\n\r\n    drawHelpDialog() {\r\n        const helpDialog = this.model.helpDialog;\r\n\r\n        if (helpDialog.visible == false) {\r\n            return;\r\n        }\r\n\r\n        this.gfx.drawRect(helpDialog.rect, 11);\r\n\r\n        this.drawMultiLineText(\r\n            helpDialog.text,\r\n            { x: helpDialog.rect.x, y: helpDialog.rect.y },\r\n            12\r\n        );\r\n\r\n        this.drawCloseButton();\r\n    }\r\n\r\n    drawCloseButton() {\r\n        const cbRect = this.model.helpDialog.closeButtonRect;\r\n\r\n        this.gfx.strokeRect(cbRect, 20);\r\n\r\n        this.gfx.drawLine(\r\n            { x: cbRect.x, y: cbRect.y },\r\n            { x: cbRect.x + cbRect.w, y: cbRect.y + cbRect.h },\r\n            20\r\n        );\r\n\r\n        this.gfx.drawLine(\r\n            { x: cbRect.x + cbRect.w, y: cbRect.y },\r\n            { x: cbRect.x, y: cbRect.y + cbRect.h },\r\n            20\r\n        );\r\n    }\r\n\r\n    drawMultiLineText(text, coord, z=0) {\r\n        for (let i = 0; i < text.length; i++) {\r\n            this.gfx.drawText(\r\n                text[i],\r\n                _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.charHeight,\r\n                {\r\n                    x: coord.x + _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.xPadding,\r\n                    y: coord.y + (_text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.charHeight * (i + 1))\r\n                },\r\n                z\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/renderer.js?");

/***/ }),

/***/ "./src/scripter.js":
/*!*************************!*\
  !*** ./src/scripter.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scripter\": () => (/* binding */ Scripter)\n/* harmony export */ });\n/* harmony import */ var _tree_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree_util */ \"./src/tree_util.js\");\n\r\n\r\nclass Logger {\r\n    constructor(boxes) {\r\n        this.boxes = boxes;\r\n        this.rootNodeId = null;\r\n    }\r\n\r\n    newNode(s, parentId) {\r\n        const id = this.boxes.addBox(s, { x: 0, y: 0 });\r\n\r\n        if (this.rootNodeId === null) {\r\n            this.rootNodeId = id;\r\n        }\r\n\r\n        if (parentId !== null) {\r\n            this.boxes.addConnection(parentId, id);\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    appendToNode(s, id) {\r\n        const box = this.boxes.getBox(id);\r\n        if (box !== null && box !== undefined) {\r\n            box.appendString(s);\r\n        }\r\n    }\r\n}\r\n\r\nclass Scripter {\r\n    constructor(model, treeFormatter) {\r\n        this.model = model;\r\n        this.boxes = model.boxes;\r\n        this.treeFormatter = treeFormatter;\r\n        this.logger = new Logger(this.boxes);\r\n        this.rootNodeId = null;\r\n    }\r\n\r\n    runUserFunction(fn) {\r\n        this.logger.rootNodeId = null;\r\n        fn(this.logger);\r\n        this.treeFormatter.treeFormat(this.logger.rootNodeId);\r\n        const treeIds = (0,_tree_util__WEBPACK_IMPORTED_MODULE_0__.getAllIdsInTree)(this.logger.rootNodeId, this.boxes);\r\n        (0,_tree_util__WEBPACK_IMPORTED_MODULE_0__.moveBoxesByDelta)(treeIds, 5, 5, this.boxes);\r\n    }\r\n\r\n    run() {\r\n        const fibResult = this.fib(5, null);\r\n        this.treeFormatter.treeFormat(this.logger.rootNodeId);\r\n    }\r\n\r\n    fib(n, parentId) {\r\n        const id = this.logger.newNode(`fib(${n})`, parentId);\r\n        let res = 0;\r\n        if (n === 0) {\r\n            res = 0;\r\n        } else if (n === 1) {\r\n            res = 1;\r\n        } else {\r\n            res = this.fib(n - 1, id) + this.fib(n - 2, id);\r\n        }\r\n        this.logger.appendToNode(` -> ${res}`, id);\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/scripter.js?");

/***/ }),

/***/ "./src/state.js":
/*!**********************!*\
  !*** ./src/state.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"State\": () => (/* binding */ State)\n/* harmony export */ });\n/* harmony import */ var _state_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state_util */ \"./src/state_util.js\");\n\r\n\r\nclass State {\r\n    constructor() {\r\n        this.initialize();\r\n\r\n        const eventListener = (e) => {\r\n            // handle keyboard events\r\n            if (e.key) {\r\n                let key = e.key.toLowerCase();\r\n                if (key === \" \") {\r\n                    key = \"space\";\r\n                } else if (key === \"enter\") {\r\n                    key = \"\\n\";\r\n                }\r\n\r\n                if (e.type === \"keydown\") {\r\n                    this.cur.keyboard[key] = true;\r\n                } else if (e.type === \"keyup\") {\r\n                    this.cur.keyboard[key] = false;\r\n                }\r\n            }\r\n\r\n            // handle mouse events\r\n            else if (e.type === \"mousedown\") {\r\n                this.cur.mouse.clicked = true;\r\n                this.cur.mouse.coord.x = e.offsetX;\r\n                this.cur.mouse.coord.y = e.offsetY;\r\n                if (this.initialMouseClick === true) {\r\n                    this.prev.mouse.coord.x = this.cur.mouse.coord.x;\r\n                    this.prev.mouse.coord.y = this.cur.mouse.coord.y;\r\n                    this.initialMouseClick = false;\r\n                }\r\n            } else if (e.type === \"mouseup\") {\r\n                this.cur.mouse.clicked = false;\r\n                this.cur.mouse.coord.x = e.offsetX;\r\n                this.cur.mouse.coord.y = e.offsetY;\r\n            } else if (e.type === \"mousemove\") {\r\n                this.cur.mouse.coord.x = e.offsetX;\r\n                this.cur.mouse.coord.y = e.offsetY;\r\n            }\r\n        }\r\n\r\n        document.addEventListener(\"keydown\", eventListener, false);\r\n        document.addEventListener(\"keyup\", eventListener, false);\r\n        document.addEventListener(\"mousedown\", eventListener, false);\r\n        document.addEventListener(\"mouseup\", eventListener, false);\r\n        document.addEventListener(\"mousemove\", eventListener, false);\r\n\r\n        // when alt-tabbing out of window, re-initialize state\r\n        // otherwise keys will stay \"stuck\" down\r\n        window.addEventListener('blur', () => {\r\n            this.initialize();\r\n        });\r\n\r\n        // prevent spacebar from scrolling\r\n        window.addEventListener('keydown', (e) => {\r\n            if (e.keyCode === 32 && e.target === document.body) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n    }\r\n\r\n    initialize() {\r\n        this.cur = (0,_state_util__WEBPACK_IMPORTED_MODULE_0__.makeState)();\r\n        this.prev = (0,_state_util__WEBPACK_IMPORTED_MODULE_0__.makeState)();\r\n        this.initialMouseClick = true;\r\n    }\r\n\r\n    isKeydown(key) {\r\n        return this.cur.keyboard[key] && !this.prev.keyboard[key];\r\n    }\r\n\r\n    isMouseInside(rect) {\r\n        const mouse = this.cur.mouse;\r\n        return (\r\n            mouse.coord.x > rect.x\r\n            && mouse.coord.x < rect.x + rect.w\r\n            && mouse.coord.y > rect.y\r\n            && mouse.coord.y < rect.y + rect.h\r\n        );\r\n    }\r\n\r\n    isMousedown() {\r\n        return this.cur.mouse.clicked && !this.prev.mouse.clicked;\r\n    }\r\n\r\n    isMouseup() {\r\n        return !this.cur.mouse.clicked && this.prev.mouse.clicked;\r\n    }\r\n\r\n    isMousedownInside(rect) {\r\n        return this.isMousedown() && this.isMouseInside(rect);\r\n    }\r\n\r\n    isMouseupInside(rect) {\r\n        return this.isMouseup() && this.isMouseInside(rect);\r\n    }\r\n\r\n    getMouseCoord() {\r\n        return this.cur.mouse.coord;\r\n    }\r\n\r\n    getMouseXDelta() {\r\n        return this.cur.mouse.coord.x - this.prev.mouse.coord.x;\r\n    }\r\n\r\n    getMouseYDelta() {\r\n        return this.cur.mouse.coord.y - this.prev.mouse.coord.y;\r\n    }\r\n\r\n    nextState() {\r\n        this.prev.mouse.coord = { ...this.cur.mouse.coord };\r\n        this.prev.mouse.clicked = this.cur.mouse.clicked;\r\n        this.prev.keyboard = { ...this.cur.keyboard };\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/state.js?");

/***/ }),

/***/ "./src/state_util.js":
/*!***************************!*\
  !*** ./src/state_util.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeState\": () => (/* binding */ makeState)\n/* harmony export */ });\nconst makeState = () => {\r\n    return {\r\n        mouse: {\r\n            clicked: false,\r\n            coord: { x: 0, y: 0 },\r\n        },\r\n        keyboard: {\r\n            arrowup: false,\r\n            arrowdown: false,\r\n            arrowright: false,\r\n            arrowleft: false,\r\n            control: false,\r\n            shift: false,\r\n            alt: false,\r\n            tab: false,\r\n            backspace: false,\r\n            space: false,\r\n            enter: false,\r\n            a: false,\r\n            b: false,\r\n            c: false,\r\n            d: false,\r\n            e: false,\r\n            f: false,\r\n            g: false,\r\n            h: false,\r\n            i: false,\r\n            j: false,\r\n            k: false,\r\n            l: false,\r\n            m: false,\r\n            n: false,\r\n            o: false,\r\n            p: false,\r\n            q: false,\r\n            r: false,\r\n            s: false,\r\n            t: false,\r\n            u: false,\r\n            v: false,\r\n            w: false,\r\n            x: false,\r\n            y: false,\r\n            z: false,\r\n        },\r\n    };\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/state_util.js?");

/***/ }),

/***/ "./src/text_constants.js":
/*!*******************************!*\
  !*** ./src/text_constants.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"textConstants\": () => (/* binding */ textConstants)\n/* harmony export */ });\nconst charHeight = 14;\r\n\r\nconst textConstants = {\r\n    textStyle: \"Consolas\",\r\n    charHeight: charHeight,\r\n    charWidth: charHeight * 0.55,\r\n    xPadding: 4,\r\n    yPadding: 6,\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/text_constants.js?");

/***/ }),

/***/ "./src/tree_formatter.js":
/*!*******************************!*\
  !*** ./src/tree_formatter.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TreeFormatter\": () => (/* binding */ TreeFormatter)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n// tree drawing algorithm adapted from:\r\n// https://rachel53461.wordpress.com/2014/04/20/algorithm-for-drawing-trees/\r\n\r\n\r\n\r\nclass TreeFormatter {\r\n    constructor(model) {\r\n        this.boxes = model.boxes;\r\n        this.defaultYPadding = 70;\r\n        this.xPadding = 50;\r\n        this.yPadding = this.defaultYPadding;\r\n    }\r\n\r\n    treeFormat(rootId) {\r\n        const maxHeight = this.getMaxHeight(rootId);\r\n\r\n        this.yPadding = maxHeight + this.defaultYPadding;\r\n\r\n        let box = this.boxes.getBox(rootId);\r\n        box.parentId = null;\r\n        this.initializeNodes(rootId, 0);\r\n        this.calculateInitialX(rootId);\r\n        this.calculateFinalPositions(rootId, 0);\r\n    }\r\n\r\n    getMaxHeight(rootId) {\r\n        const s = [];\r\n        s.push(rootId);\r\n        let maxHeight = -1;\r\n\r\n        while (s.length !== 0) {\r\n            let curId = s.pop();\r\n            let curBox = this.boxes.getBox(curId);\r\n            maxHeight = Math.max(maxHeight, curBox.rect.h);\r\n            const childIds = this.boxes.getConnections(curId);\r\n            for (const elt of childIds) {\r\n                s.push(elt);\r\n            }\r\n        }\r\n\r\n        return maxHeight;\r\n    }\r\n\r\n    initializeNodes(id, level) {\r\n        let box = this.boxes.getBox(id);\r\n\r\n        box.setCoord({\r\n            x: 0,\r\n            y: level * this.yPadding\r\n        });\r\n\r\n        box.mod = 0;\r\n\r\n        const childIds = this.boxes.getConnections(id);\r\n        for (const cid of childIds) {\r\n            let childBox = this.boxes.getBox(cid);\r\n            childBox.parentId = id;\r\n            this.initializeNodes(cid, level + 1);\r\n        }\r\n    }\r\n\r\n    calculateInitialX(id) {\r\n        const box = this.boxes.getBox(id);\r\n        const prevSibId = this.boxes.getPrevSibling(id);\r\n        const prevSib = this.boxes.getBox(prevSibId);\r\n        const childIds = this.boxes.getConnections(id);\r\n\r\n        for (const cid of childIds) {\r\n            this.calculateInitialX(cid);\r\n        }\r\n\r\n        if (this.boxes.isLeaf(id)) {\r\n            if (!this.boxes.isLeftMost(id)) {\r\n                box.setX(prevSib.coord.x + prevSib.rect.w + this.xPadding);\r\n            } else {\r\n                box.setX(0);\r\n            }\r\n        } else if (childIds.length === 1) {\r\n            const child = this.boxes.getBox((0,_util__WEBPACK_IMPORTED_MODULE_0__.firstElt)(childIds));\r\n            if (this.boxes.isLeftMost(id)) {\r\n                box.setX(child.coord.x)\r\n            } else {\r\n                box.setX(prevSib.coord.x + prevSib.rect.w + this.xPadding);\r\n                box.mod = box.coord.x - child.coord.x;\r\n            }\r\n        } else {\r\n            const lChildId = this.boxes.getLeftMostChild(id);\r\n            const lChild = this.boxes.getBox(lChildId);\r\n            const rChildId = this.boxes.getRightMostChild(id);\r\n            const rChild = this.boxes.getBox(rChildId);\r\n            const mid = (lChild.coord.x + rChild.coord.x) / 2;\r\n\r\n            if (this.boxes.isLeftMost(id)) {\r\n                box.setX(mid);\r\n            } else {\r\n                box.setX(prevSib.coord.x + prevSib.rect.w + this.xPadding);\r\n                box.mod = box.coord.x - mid;\r\n            }\r\n        }\r\n\r\n        if (childIds.length > 0 && !this.boxes.isLeftMost(id)) {\r\n            this.checkForConflicts(id);\r\n        }\r\n    }\r\n\r\n    checkForConflicts(id) {\r\n        const box = this.boxes.getBox(id);\r\n        let siblingId = this.boxes.getLeftMostSibling(id);\r\n\r\n        const minDistance = box.rect.w + this.xPadding;\r\n\r\n        let shiftValue = 0;\r\n        let nodeContour = new Map();\r\n        this.getLeftContour(id, 0, nodeContour);\r\n\r\n        while (siblingId !== null && siblingId !== id) {\r\n            let siblingContour = new Map();\r\n            this.getRightContour(siblingId, 0, siblingContour);\r\n\r\n            const sMax = getMaxKey(siblingContour);\r\n            const nMax = getMaxKey(nodeContour);\r\n\r\n            for (\r\n                let level = box.coord.y + 1;\r\n                level <= Math.min(sMax, nMax);\r\n                level++\r\n            ) {\r\n                let distance = nodeContour.get(level) - siblingContour.get(level);\r\n                if (distance + shiftValue < minDistance) {\r\n                    shiftValue = minDistance - distance\r\n                }\r\n            }\r\n\r\n            if (shiftValue > 0) {\r\n                box.setX(box.coord.x + shiftValue);\r\n                box.mod += shiftValue;\r\n\r\n                this.centerNodesBetween(id, siblingId);\r\n\r\n                shiftValue = 0;\r\n            }\r\n\r\n            siblingId = this.boxes.getNextSibling(siblingId);\r\n        }\r\n    }\r\n\r\n    getLeftContour(id, modSum, values) {\r\n        const box = this.boxes.getBox(id);\r\n        const childIds = this.boxes.getConnections(id);\r\n\r\n        if (!values.has(box.coord.y)) {\r\n            values.set(box.coord.y, box.coord.x + modSum);\r\n        } else {\r\n            let oldVal = values.get(box.coord.y);\r\n            let newVal = Math.min(oldVal, box.coord.x + modSum);\r\n            values.set(box.coord.y, newVal);\r\n        }\r\n\r\n        modSum += box.mod;\r\n\r\n        for (const cid of childIds) {\r\n            this.getLeftContour(cid, modSum, values);\r\n        }\r\n    }\r\n\r\n    getRightContour(id, modSum, values) {\r\n        const box = this.boxes.getBox(id);\r\n        const childIds = this.boxes.getConnections(id);\r\n\r\n        if (!values.has(box.coord.y)) {\r\n            values.set(box.coord.y, box.coord.x + modSum);\r\n        } else {\r\n            let oldVal = values.get(box.coord.y);\r\n            let newVal = Math.max(oldVal, box.coord.x + modSum);\r\n            values.set(box.coord.y, newVal);\r\n        }\r\n\r\n        modSum += box.mod;\r\n\r\n        for (const cid of childIds) {\r\n            this.getRightContour(cid, modSum, values);\r\n        }\r\n    }\r\n\r\n    centerNodesBetween(leftId, rightId) {\r\n        const leftBox = this.boxes.getBox(leftId);\r\n        const rightBox = this.boxes.getBox(rightId);\r\n\r\n        const leftParentChildIds = this.boxes.getConnections(leftBox.parentId);\r\n        const leftIdx = leftParentChildIds.indexOf(leftId);\r\n\r\n        const rightParentChildIds = this.boxes.getConnections(rightBox.parentId);\r\n        const rightIdx = rightParentChildIds.indexOf(rightId);\r\n\r\n        let numNodesBetween = (rightIdx - leftIdx) - 1;\r\n\r\n        if (numNodesBetween > 0) {\r\n            let distanceBetweenNodes = (\r\n                (leftBox.coord.x - rightBox.coord.x) / (numNodesBetween + 1)\r\n            );\r\n\r\n            let count = 1;\r\n\r\n            for (let i = leftIdx + 1; i < rightIdx; i++) {\r\n                let middleNodeId = leftParentChildIds[i];\r\n                let middleNode = this.boxes.getBox(middleNodeId);\r\n\r\n                let desiredX = rightBox.coord.x + (distanceBetweenNodes * count);\r\n                let offset = desiredX - middleNode.coord.x;\r\n                middleNode.setX(middleNode.coord.x + offset);\r\n                middleNode.mod += offset;\r\n\r\n                count++;\r\n            }\r\n\r\n            this.checkForConflicts(leftId);\r\n        }\r\n    }\r\n\r\n    calculateFinalPositions(id, modSum) {\r\n        const box = this.boxes.getBox(id);\r\n        const childIds = this.boxes.getConnections(id);\r\n\r\n        box.setX(box.coord.x + modSum);\r\n        modSum += box.mod;\r\n\r\n        for (const cid of childIds) {\r\n            this.calculateFinalPositions(cid, modSum);\r\n        }\r\n    }\r\n\r\n\r\n    // left layout ////////////////////////////////////////////\r\n\r\n    leftLayout(rootNodeId) {\r\n        let levels = this.makeLevels(rootNodeId);\r\n\r\n        const xStart = 500;\r\n        const yStart = 100;\r\n        const xPadding = 40;\r\n        const yPadding = 80;\r\n\r\n        let x = xStart;\r\n        let y = yStart;\r\n\r\n        for (let i = 0; i < levels.length; i++) {\r\n            let curLevel = levels[i];\r\n            x = xStart;\r\n            for (let k = 0; k < curLevel.length; k++) {\r\n                let box = this.boxes.getBox(curLevel[k]);\r\n                box.setCoord({ x, y });\r\n                x += box.rect.w + xPadding;\r\n            }\r\n            y += yPadding;\r\n        }\r\n    }\r\n\r\n    makeLevels(rootNodeId) {\r\n        let queue = [];\r\n        let levels = [];\r\n        let curLevel = 0;\r\n\r\n        queue.push(rootNodeId);\r\n\r\n        while (queue.length > 0) {\r\n            const n = queue.length;\r\n            for (let i = 0; i < n; i++) {\r\n                const curId = queue.shift();\r\n                const childrenIds = this.boxes.getConnections(curId);\r\n                for (const cid of childrenIds) {\r\n                    queue.push(cid);\r\n                }\r\n                if (levels.length - 1 < curLevel) {\r\n                    levels.push([]);\r\n                }\r\n                levels[curLevel].push(curId);\r\n            }\r\n            curLevel++;\r\n        }\r\n\r\n        return levels;\r\n    }\r\n}\r\n\r\nconst getMaxKey = (map) => {\r\n    let keys = Array.from(map.keys());\r\n    return Math.max(...keys);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/tree_formatter.js?");

/***/ }),

/***/ "./src/tree_util.js":
/*!**************************!*\
  !*** ./src/tree_util.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAllIdsInTree\": () => (/* binding */ getAllIdsInTree),\n/* harmony export */   \"isTree\": () => (/* binding */ isTree),\n/* harmony export */   \"moveBoxes\": () => (/* binding */ moveBoxes),\n/* harmony export */   \"moveBoxesByDelta\": () => (/* binding */ moveBoxesByDelta)\n/* harmony export */ });\nconst depthFirstTraversal = (rootId, boxes, fn) => {\r\n    let stack = [];\r\n    stack.push(rootId);\r\n\r\n    let childIds = null;\r\n    let curId = null;\r\n\r\n    while (stack.length > 0) {\r\n        curId = stack.pop();\r\n        fn(curId);\r\n        childIds = boxes.getConnections(curId);\r\n        stack.push(...childIds);\r\n    }\r\n}\r\n\r\nconst getAllIdsInTree = (rootId, boxes) => {\r\n    let nodes = [];\r\n    const fn = (id) => nodes.push(id);\r\n    depthFirstTraversal(rootId, boxes, fn);\r\n    return nodes;\r\n}\r\n\r\nconst isTree = (rootId, boxes) => {\r\n    let stack = [];\r\n    let set = new Set();\r\n    stack.push(rootId);\r\n\r\n    let childIds = null;\r\n    let curId = null;\r\n\r\n    while (stack.length > 0) {\r\n        curId = stack.pop();\r\n        if (set.has(curId)) {\r\n            return false;\r\n        } else {\r\n            set.add(curId);\r\n        }\r\n        childIds = boxes.getConnections(curId);\r\n        stack.push(...childIds);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nconst moveBoxes = (ids, coord, boxes) => {\r\n    if (ids.length === 0) {\r\n        return;\r\n    }\r\n\r\n    const rootId = ids[0];\r\n    const rootBox = boxes.getBox(rootId);\r\n    const xDelta = coord.x - rootBox.coord.x;\r\n    const yDelta = coord.y - rootBox.coord.y;\r\n\r\n    for (const id of ids) {\r\n        const box = boxes.getBox(id);\r\n        box.setCoord({\r\n            x: box.coord.x + xDelta,\r\n            y: box.coord.y + yDelta\r\n        });\r\n    }\r\n}\r\n\r\nconst moveBoxesByDelta = (ids, xDelta, yDelta, boxes) => {\r\n    for (const id of ids) {\r\n        const box = boxes.getBox(id);\r\n        box.setCoord({\r\n            x: box.coord.x + xDelta,\r\n            y: box.coord.y + yDelta\r\n        });\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/tree_util.js?");

/***/ }),

/***/ "./src/ui.js":
/*!*******************!*\
  !*** ./src/ui.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ui\": () => (/* binding */ Ui)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n/* harmony import */ var _tree_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tree_util */ \"./src/tree_util.js\");\n\r\n\r\n\r\n\r\nconst addEventListener = (type, callback) => {\r\n    document.addEventListener(type, callback, false);\r\n}\r\n\r\nclass Ui {\r\n    constructor(state, model, eventTable, scripter, treeFormatter) {\r\n        this.state = state;\r\n        this.model = model;\r\n        this.eventTable = eventTable;\r\n        this.scripter = scripter;\r\n        this.treeFormatter = treeFormatter;\r\n        this.prevFileHandle = null;\r\n        this.drag = false;\r\n        this.dragCoord = { x: 0, y: 0 };\r\n        this.dragDeltaCoord = { x: 0, y: 0 };\r\n\r\n        addEventListener(\"mousedown\", e => this.eventTable.onEvent(e));\r\n        addEventListener(\"mouseup\", e => this.eventTable.onEvent(e));\r\n        addEventListener(\"dblclick\", e => this.eventTable.onEvent(e));\r\n        addEventListener(\"keydown\", e => this.eventTable.onEvent(e));\r\n\r\n        this.addEventListeners();\r\n    }\r\n\r\n    addEventListeners() {\r\n        this.eventTable.addEvent(\r\n            \"beginConnection\",\r\n            e => e.mousedown && e.insideBox && e.keyboard.control,\r\n            e => {\r\n                this.model.lineBegin = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getMidpoint)(e.mouseBox.rect);\r\n                this.model.outBox = e.mouseBox;\r\n                this.model.drawingLine = true;\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"addConnection\",\r\n            e => e.mouseup && e.insideBox && this.model.drawingLine,\r\n            e => {\r\n                this.model.boxes.addConnection(\r\n                    this.model.outBox.id,\r\n                    e.mouseBox.id\r\n                );\r\n                this.model.drawingLine = false;\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"addBox\",\r\n            e => e.dblclick && !e.insideBox,\r\n            e => {\r\n                const text = \"\";\r\n                const newBoxId = this.model.boxes.addBox(text, e.mouse.coord);\r\n                this.model.clearSelectedBoxIds();\r\n                this.model.addSelectedBoxId(newBoxId);\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"duplicateBox\",\r\n            e => e.mousedown && e.keyboard.alt && e.insideBox,\r\n            e => {\r\n                // const newBoxId = this.model.boxes.addBox(e.mouseBox.text, e.mouse.coord);\r\n                const newBoxId = this.model.boxes.cloneBox(e.mouseBox, e.mouse.coord);\r\n                this.model.clearSelectedBoxIds();\r\n                this.model.addSelectedBoxId(newBoxId);\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"deleteBox\",\r\n            e => e.keydown && e.key_ === \"delete\" && this.model.anyBoxesSelected(),\r\n            e => {\r\n                for (const id of this.model.selectedBoxIds) {\r\n                    this.model.boxes.deleteBox(id);\r\n                }\r\n                this.model.clearSelectedBoxIds();\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"clickAndSelectBox\",\r\n            e => {\r\n                return e.mousedown\r\n                    && e.insideBox\r\n                    && !e.keyboard.control\r\n                    && !e.keyboard.shift\r\n                    && !e.keyboard.alt\r\n                    && !this.model.isBoxSelected(e.mouseBox.id);\r\n            },\r\n            e => {\r\n                this.model.clearSelectedBoxIds();\r\n                this.model.addSelectedBoxId(e.mouseBox.id);\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"shiftClickAndAddSelectBox\",\r\n            e => e.mousedown && e.insideBox && !e.keyboard.control && e.keyboard.shift,\r\n            e => this.model.addSelectedBoxId(e.mouseBox.id)\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"clickAndUnselectBox\",\r\n            e => e.mousedown && !e.insideBox && !e.keyboard.control && !e.keyboard.alt,\r\n            e => this.model.clearSelectedBoxIds()\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"beginDraggingBoxes\",\r\n            e => e.mousedown && !e.keyboard.control && e.insideBox,\r\n            e => this.model.draggingBoxes = true\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"endDraggingBoxes\",\r\n            e => e.mouseup,\r\n            e => this.model.draggingBoxes = false\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"beginDraggingSelectedRegion\",\r\n            e => e.mousedown && !e.keyboard.control && !e.insideBox,\r\n            e => {\r\n                this.model.draggingSelectedRegion = true;\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"endDraggingSelectedRegion\",\r\n            e => e.mouseup,\r\n            e => this.model.draggingSelectedRegion = false\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"setSelectedRegionCoords\",\r\n            e => e.mousedown && !e.keyboard.control,\r\n            e => {\r\n                this.model.selectedRegion = {\r\n                    x: e.mouse.coord.x,\r\n                    y: e.mouse.coord.y,\r\n                    w: 0,\r\n                    h: 0,\r\n                    alpha: 0.3,\r\n                };\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"endDrawingLine\",\r\n            e => e.mouseup,\r\n            e => this.model.drawingLine = false\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"appendString\",\r\n            e => {\r\n                return e.keydown\r\n                    && this.model.anyBoxesSelected()\r\n                    && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isPrintableKeycode)(e.which)\r\n                    && !e.keyboard.control\r\n            },\r\n            e => {\r\n                for (const id of this.model.selectedBoxIds) {\r\n                    let box = this.model.boxes.getBox(id);\r\n                    box.appendString(e.key_);\r\n                }\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"deleteChar\",\r\n            e => {\r\n                return e.keydown\r\n                    && this.model.anyBoxesSelected()\r\n                    && e.key_ === \"backspace\";\r\n            },\r\n            e => {\r\n                for (const id of this.model.selectedBoxIds) {\r\n                    let box = this.model.boxes.getBox(id);\r\n                    box.deleteChar();\r\n                }\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"horizontalAlign\",\r\n            e => e.keydown && e.keyboard.control && e.keyboard.h,\r\n            e => {\r\n                e.preventDefault();\r\n                let minY = Number.MAX_SAFE_INTEGER;\r\n                for (const id of this.model.selectedBoxIds) {\r\n                    let box = this.model.boxes.getBox(id);\r\n                    minY = Math.min(minY, box.coord.y);\r\n                }\r\n\r\n                for (const id of this.model.selectedBoxIds) {\r\n                    let box = this.model.boxes.getBox(id);\r\n                    box.setCoord({ x: box.coord.x, y: minY });\r\n                }\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"verticalAlign\",\r\n            e => e.keydown && e.keyboard.control && e.keyboard.v,\r\n            e => {\r\n                e.preventDefault();\r\n                let minXMid = Number.MAX_SAFE_INTEGER;\r\n                for (const id of this.model.selectedBoxIds) {\r\n                    let box = this.model.boxes.getBox(id);\r\n                    minXMid = Math.min(\r\n                        minXMid,\r\n                        Math.floor(box.rect.x + (box.rect.w / 2))\r\n                    );\r\n                }\r\n\r\n                for (const id of this.model.selectedBoxIds) {\r\n                    let box = this.model.boxes.getBox(id);\r\n                    box.setCoord({\r\n                        x: minXMid - Math.floor(box.rect.w / 2),\r\n                        y: box.coord.y\r\n                    });\r\n                }\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"treeFormat\",\r\n            e => (\r\n                e.keydown\r\n                && e.keyboard.control\r\n                && e.keyboard.q\r\n                && this.model.selectedBoxIds.length === 1\r\n            ),\r\n            e => {\r\n                const selectedBox = this.model.selectedBoxIds[0]\r\n                if (!(0,_tree_util__WEBPACK_IMPORTED_MODULE_1__.isTree)(selectedBox, this.model.boxes)) {\r\n                    console.log(\"not a tree!\");\r\n                    return;\r\n                }\r\n                this.treeFormatter.treeFormat(selectedBox);\r\n                const treeIds = (0,_tree_util__WEBPACK_IMPORTED_MODULE_1__.getAllIdsInTree)(selectedBox, this.model.boxes);\r\n                (0,_tree_util__WEBPACK_IMPORTED_MODULE_1__.moveBoxes)(treeIds, this.state.cur.mouse.coord, this.model.boxes);\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"selectAll\",\r\n            e => e.keydown && e.keyboard.control && e.keyboard.a,\r\n            e => {\r\n                this.model.clearSelectedBoxIds();\r\n                this.model.boxes.forEach(elt => {\r\n                    this.model.addSelectedBoxId(elt.id);\r\n                });\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"saveFile\",\r\n            e => e.keydown && e.keyboard.control && e.keyboard.s,\r\n            async e => {\r\n                e.preventDefault();\r\n                try {\r\n                    const boxesStr = JSON.stringify(this.model.boxes.boxes);\r\n                    const connStr = JSON.stringify([...this.model.boxes.connections]);\r\n                    await (0,_util__WEBPACK_IMPORTED_MODULE_0__.saveFile)(boxesStr + \"\\n\" + connStr);\r\n                } catch (e) {\r\n                    console.log(e);\r\n                }\r\n                this.state.cur.keyboard.control = false;\r\n                this.state.cur.keyboard.s = false;\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"loadFile\",\r\n            e => e.keydown && e.keyboard.control && !e.keyboard.shift && e.keyboard.l,\r\n            async e => {\r\n                e.preventDefault();\r\n                try {\r\n                    const [_, content] = await (0,_util__WEBPACK_IMPORTED_MODULE_0__.loadFile)();\r\n                    this.model.init();\r\n                    const [boxesStr, connStr] = content.split(/\\n/);\r\n                    this.model.boxes.loadBoxes(boxesStr);\r\n                    this.model.boxes.loadConnections(connStr);\r\n                } catch (e) {\r\n                    console.log(e);\r\n                }\r\n                this.state.cur.keyboard.control = false;\r\n                this.state.cur.keyboard.l = false;\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"loadScript\",\r\n            e => e.keydown && e.keyboard.control && e.keyboard.shift && !e.keyboard.alt && e.keyboard.l,\r\n            async e => {\r\n                e.preventDefault();\r\n                try {\r\n                    const scriptElt = document.createElement(\"script\");\r\n                    const [fileHandle, content] = await (0,_util__WEBPACK_IMPORTED_MODULE_0__.loadFile)();\r\n                    this.prevFileHandle = fileHandle;\r\n                    const textNode = document.createTextNode(content);\r\n                    scriptElt.appendChild(textNode);\r\n                    const targetElt = document.getElementById(\"userScripts\");\r\n                    targetElt.append(scriptElt);\r\n                    this.model.init();\r\n                    setTimeout(() => {}, 0);    // wait for one event-cycle\r\n                    this.scripter.runUserFunction(userFunction);\r\n                } catch (e) {\r\n                    console.log(e);\r\n                }\r\n                this.state.cur.keyboard.control = false;\r\n                this.state.cur.keyboard.shift = false;\r\n                this.state.cur.keyboard.l = false;\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"reloadScript\",\r\n            e => e.keydown && e.keyboard.control && e.keyboard.shift && e.keyboard.alt && e.keyboard.l,\r\n            async e => {\r\n                e.preventDefault();\r\n                try {\r\n                    if (this.prevFileHandle === null) {\r\n                        return;\r\n                    }\r\n                    const scriptElt = document.createElement(\"script\");\r\n                    const content = await (0,_util__WEBPACK_IMPORTED_MODULE_0__.loadFileFromHandle)(this.prevFileHandle);\r\n                    const textNode = document.createTextNode(content);\r\n                    scriptElt.appendChild(textNode);\r\n                    const targetElt = document.getElementById(\"userScripts\");\r\n                    targetElt.append(scriptElt);\r\n                    this.model.init();\r\n                    setTimeout(() => {}, 0);    // wait for one event-cycle\r\n                    this.scripter.runUserFunction(userFunction);\r\n                } catch (e) {\r\n                    console.log(e);\r\n                }\r\n                this.state.cur.keyboard.control = false;\r\n                this.state.cur.keyboard.shift = false;\r\n                this.state.cur.keyboard.alt = false;\r\n                this.state.cur.keyboard.l = false;\r\n            }\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"closeHelpDialog\",\r\n            e => (\r\n                e.mousedown\r\n                && this.state.isMouseInside(this.model.helpDialog.closeButtonRect)\r\n                && this.model.helpDialog.visible\r\n            ),\r\n            e => this.model.helpDialog.visible = false\r\n        );\r\n\r\n        this.eventTable.addEvent(\r\n            \"printAllBoxes\",\r\n            e => e.keydown && e.keyboard.control && e.keyboard.space,\r\n            e => {\r\n                console.log(this.model.boxes);\r\n                console.log(window.pageXOffset);\r\n                console.log(window.pageYOffset);\r\n            }\r\n        );\r\n    }\r\n\r\n    handleDragging() {\r\n        if (this.model.draggingBoxes && this.model.anyBoxesSelected()) {\r\n            // drag boxes\r\n            for (const id of this.model.selectedBoxIds) {\r\n                const box = this.model.boxes.getBox(id);\r\n\r\n                const newCoord = {\r\n                    x: box.coord.x + this.state.getMouseXDelta(),\r\n                    y: box.coord.y + this.state.getMouseYDelta()\r\n                };\r\n\r\n                box.setCoord(newCoord);\r\n            }\r\n        } else if (this.model.draggingSelectedRegion) {\r\n            // drag selected region\r\n            this.model.selectedRegion.w += this.state.getMouseXDelta();\r\n            this.model.selectedRegion.h += this.state.getMouseYDelta();\r\n\r\n            this.model.boxes.forEach(box => {\r\n                if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.rectsOverlap)(box.rect, this.model.selectedRegion)) {\r\n                    this.model.addSelectedBoxId(box.id);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    handleScrolling() {\r\n        const kb = this.state.cur.keyboard;\r\n        if (\r\n            !kb.control\r\n            && !this.model.anyBoxesSelected()\r\n            && (kb.w || kb.a || kb.s || kb.d)\r\n        ) {\r\n            const scrollAmount = 10;\r\n            const oldXOffset = window.pageXOffset;\r\n            const oldYOffset = window.pageYOffset;\r\n\r\n            if (kb.w) {\r\n                window.scroll(oldXOffset, oldYOffset - scrollAmount);\r\n            }\r\n\r\n            if (kb.a) {\r\n                window.scroll(oldXOffset - scrollAmount, oldYOffset);\r\n            }\r\n\r\n            if (kb.s) {\r\n                window.scroll(oldXOffset, oldYOffset + scrollAmount);\r\n            }\r\n\r\n            if (kb.d) {\r\n                window.scroll(oldXOffset + scrollAmount, oldYOffset);\r\n            }\r\n        }\r\n    }\r\n\r\n    run() {\r\n        this.handleDragging();\r\n        this.handleScrolling();\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/ui.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getMidpoint\": () => (/* binding */ getMidpoint),\n/* harmony export */   \"distanceBetweenCoords\": () => (/* binding */ distanceBetweenCoords),\n/* harmony export */   \"rectsOverlap\": () => (/* binding */ rectsOverlap),\n/* harmony export */   \"isPrintableKeycode\": () => (/* binding */ isPrintableKeycode),\n/* harmony export */   \"saveFile\": () => (/* binding */ saveFile),\n/* harmony export */   \"loadFile\": () => (/* binding */ loadFile),\n/* harmony export */   \"loadFileFromHandle\": () => (/* binding */ loadFileFromHandle),\n/* harmony export */   \"getTextRect\": () => (/* binding */ getTextRect),\n/* harmony export */   \"getWidthOfText\": () => (/* binding */ getWidthOfText),\n/* harmony export */   \"firstElt\": () => (/* binding */ firstElt),\n/* harmony export */   \"lastElt\": () => (/* binding */ lastElt),\n/* harmony export */   \"clearArray\": () => (/* binding */ clearArray)\n/* harmony export */ });\n/* harmony import */ var _text_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text_constants */ \"./src/text_constants.js\");\n\r\n\r\nconst getMidpoint = (rect) => {\r\n    return {\r\n        x: rect.x + (rect.w / 2),\r\n        y: rect.y + (rect.h / 2)\r\n    };\r\n};\r\n\r\nconst distanceBetweenCoords = (coord1, coord2) => {\r\n    const a = Math.abs(coord1.x - coord2.x);\r\n    const b = Math.abs(coord1.y - coord2.y);\r\n    return Math.sqrt(a*a + b*b);\r\n};\r\n\r\nconst handleNegs = (rect) => {\r\n    let newRect = { ...rect };\r\n\r\n    if (newRect.w < 0) {\r\n        newRect.x += newRect.w;\r\n        newRect.w = Math.abs(newRect.w);\r\n    }\r\n\r\n    if (newRect.h < 0) {\r\n        newRect.y += newRect.h;\r\n        newRect.h = Math.abs(newRect.h)\r\n    }\r\n\r\n    return newRect;\r\n};\r\n\r\nconst rectsOverlap = (rect1, rect2) => {\r\n    rect1 = handleNegs(rect1);\r\n    rect2 = handleNegs(rect2);\r\n\r\n    return (\r\n        rect1.x < rect2.x + rect2.w &&\r\n        rect1.x + rect1.w > rect2.x &&\r\n        rect1.y < rect2.y + rect2.h &&\r\n        rect1.y + rect1.h > rect2.y\r\n    );\r\n};\r\n\r\nconst isPrintableKeycode = (kc) => {\r\n    return (\r\n        (kc === 13)                 // enter\r\n        || (kc === 32)              // spacebar\r\n        || (kc > 47 && kc < 58)     // number keys\r\n        || (kc > 64 && kc < 91)     // letter keys\r\n        || (kc > 95 && kc < 112)    // numpad keys\r\n        || (kc > 185 && kc < 193)   // ;=,-./`\r\n        || (kc > 218 && kc < 223)   // [\\]'\r\n    );\r\n};\r\n\r\n// see: https://web.dev/file-system-access/\r\nconst saveFile = async (content) => {\r\n    const options = {\r\n        types: [{\r\n            description: 'Text Files',\r\n            accept: { 'text/plain': ['.txt'] }\r\n        }]\r\n    };\r\n\r\n    const fileHandle = await window.showSaveFilePicker(options);\r\n    const writable = await fileHandle.createWritable();\r\n    await writable.write(content);\r\n    await writable.close();\r\n};\r\n\r\nconst loadFile = async () => {\r\n    const [fileHandle] = await window.showOpenFilePicker();\r\n    const file = await fileHandle.getFile();\r\n    const content = await file.text();\r\n    return [fileHandle, content];\r\n};\r\n\r\nconst loadFileFromHandle = async (fileHandle) => {\r\n    const file = await fileHandle.getFile();\r\n    const content = await file.text();\r\n    return content;\r\n};\r\n\r\nconst getTextRect = (text, coord) => {\r\n    let maxWidth = -1;\r\n\r\n    for (const str of text) {\r\n        const curWidth = getWidthOfText(\r\n            str,\r\n            _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.charWidth,\r\n            _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.xPadding\r\n        );\r\n\r\n        maxWidth = Math.max(maxWidth, curWidth);\r\n    }\r\n\r\n    let rect = {\r\n        x: coord.x,\r\n        y: coord.y,\r\n        w: maxWidth,\r\n    };\r\n\r\n    rect.h = (_text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.charHeight * text.length) + _text_constants__WEBPACK_IMPORTED_MODULE_0__.textConstants.yPadding;\r\n\r\n    return rect;\r\n}\r\n\r\nconst getWidthOfText = (text, charWidth, xPadding) => {\r\n    let len = text.length > 0 ? text.length : 1;\r\n    return Math.floor(len * charWidth) + (xPadding * 2);\r\n};\r\n\r\nconst firstElt = (arr) => {\r\n    if (arr.length === 0) {\r\n        return null;\r\n    } else {\r\n        return arr[0];\r\n    }\r\n}\r\n\r\nconst lastElt = (arr) => {\r\n    if (arr.length === 0) {\r\n        return null;\r\n    } else {\r\n        return arr[arr.length - 1];\r\n    }\r\n}\r\n\r\nconst clearArray = (arr) => {\r\n    while (arr.length > 0) {\r\n        arr.pop();\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://boxes-and-lines/./src/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;